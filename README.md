# Regulus
Regulus is a hot update solution for Unity. 
It has almost the same easy-to-use interface as InjectFix but with much better optimizations.

*Warning: Regulus is an educational hot update framework, it should not be used in production*

## Benchmark Results
In the performance evaluation experiments of hot update frameworks, we use Unity version 2023.1.7f1, compiled with the Mono backend under non-Development Build mode, and the output platform is Windows Intel-64bit. Here we don't use the Function Redirection and JIT features of ILRuntime, since we want to compare register-based bytecode with stack-based bytecode. So this is a weak ILRuntime baseline.

We constructed nine groups of tests. For mathematical computation, we used Sum, which performs an arithmetic series summation from 1 to 10^8. For recursive functions, we used Fib, which implements the Fibonacci sequence recursively with an input parameter of 35. For array access, the tests include Sieve and Bubble. Sieve refers to the Sieve of Eratosthenes with an input of 10^7, while Bubble performs a bubble sort on 10,000 numbers arranged in reverse order.

For member access, we designed MA and SMA. MA represents intensive instance member access operations, whereas SMA represents intensive static member access operations. In these two tests, we constructed an object containing primitive types, value types, and reference types, and performed repeated read and write operations on the fields of these three types.

For Unity-related code, we selected Vector, Transform, and Collision. These mainly cover the most common operations in Unity projects, namely vector operations, transform manipulations, and collision detection.

Each test was executed ten times on the test machine, and we recorded the average execution time and standard deviation in the table below (in milliseconds). In the performance comparison, we evaluated our method against existing open-source frameworks based on C# bytecode, as well as direct function calls.

| Program       | Direct Call (ms)   | ILRuntime (ms)     | InjectFix (ms)    | Regulus (ms)   |
|:----------:|:---------------:|:-----------------:|:----------------:|:----------------:|
| **Sum**        | 51.00±10.33    | 8195.90±271.41    | 6749.09±318.52   | 1393.80±218.42   |
| **Fib**        | 76.90±13.55    | 6346.45±1924.91   | 15699.91±295.44  | 629.90±105.02    |
| **Sieve**      | 156.50±12.46   | 9987.50±1043.05   | 4890.18±201.37   | 1575.10±184.77   |
| **Bubble**     | 137.10±13.58   | 31205.91±8709.75  | 19497.20±931.73  | 5066.90±397.14   |
| **MA**         | 13.60±3.29     | 633.70±28.79      | 698.30±25.35     | 483.10±25.19     |
| **SMA**        | 15.50±3.26     | 467.60±32.51      | 640.20±14.19     | 391.40±25.99     |
| **Vector**     | 9.45±0.66      | 2302.31±351.02    | 2165.60±27.70    | 907.10±89.06     |
| **Transform**  | 31.40±3.32     | 1113.00±171.85    | 901.70±14.23     | 662.50±22.54     |
| **Collision**  | 567.50±26.35   | 14191.00±522.27   | 16345.10±313.43  | 12546.10±219.15  |

## Framework Structure Overview

The overall framework is divided into three parts: a function-level code instrumentation tool, a compiler that translates CIL into custom bytecode, and a virtual machine that interprets and executes the custom bytecode. 

### Function-Level Instrumentation

In the design of the hot update framework, to minimize the invasiveness to the project's source code, the approach typically selects instrumentation at the CIL code level generated by C#. This enables the dynamic detection of patch status to implement the hot update mechanism. When no patch exists, the original code is executed directly. When a patch exists, the virtual machine interprets and executes the patch, achieving the hot update.
```Csharp
public int Test(int a) {
  if (PatchApplicator.HasPatch(patchId)) {
    return PatchApplicator.RunPatch(patchId, a);
  }
  // below is the original code of Test(int)
}
```

In this framework, the hot update is applied at the function level. Figure 2.1 shows a simple schematic of the principle.

### Design of Custom Instruction Set
#### Instruction Design with Explicit Operands
CIL is a stack-based instruction set where instructions do not explicitly contain operands. Inspired by Lua and ILRuntime, the instruction format is optimized by changing it to a register-based form. Taking the addition instruction as an example: In CIL, the add instruction pops two operands from the stack, adds them, and pushes the result back onto the stack. This means that during one addition operation, CIL needs to first load the operands onto the stack, perform the calculation, and then copy the result from the stack into the target variable. By changing to an explicit operand instruction format, unnecessary data movement can be reduced during interpretation, thereby improving execution efficiency.
Original CIL Instructions:
```CSharp
ldloc.0     // Load local variable 0 onto the stack
ldloc.1     // Load local variable 1 onto the stack
add         // Add the two numbers on the stack
stloc.2     // Store the result back into local variable 2
```

Custom Instruction:
```CSharp
add Local2, Local0, Local1 // Add local0 and local1, store the result in Local2
```

#### Instructions with Type Information

When executing CIL bytecode, the virtual machine needs to maintain the type information of each operand. However, the type of the operands in CIL operations is typically inferred during compilation. For example, the sub instruction itself does not contain type information, and the operation depends on the data type of the operands at runtime. If the operands are integers, it performs integer subtraction; if they are floating-point numbers, it performs floating-point subtraction. This means that the virtual machine must maintain the type information of all data during the execution of instructions, which increases both memory overhead and runtime costs due to type inference.

To address this, the original sub instruction is split into multiple variants with explicit type information, such as Sub_Int for integer subtraction and Sub_Float for floating-point subtraction. This allows the type information that would otherwise be maintained at runtime to be handled at compile time. This design approach is inspired by HybridCLR.

#### Instructions with Immediate Values

The custom instruction set introduces immediate versions of several instructions. These instructions can directly embed constants, thereby reducing unnecessary constant loading operations, which is crucial for improving mathematical operation efficiency. As shown in Figure 2.3, in the original CIL, any computation involving a constant first requires loading the constant onto the stack before performing the operation. If the custom instructions do not include an immediate version of an instruction, the constant loading instruction cannot be omitted. Therefore, we design certain immediate instructions to reduce redundant constant loading.

Original instructions:
```CSharp
ldc.i4.1
ldloc.0
add
stloc.0
// Load integer 1 onto the stack
// Load local variable 0 onto the stack
// Add the top two numbers on the stack, the result is pushed onto the stack
// Store the top number back into local variable 0
```
Custom instruction:
```CSharp
// Add local variable 0 and integer 1, store the result into local variable 0
add Local0, Local0, Const0[1]
```

### Overview of compiler design

Different from other optimized Unity framework which will simulate the execution of MSIL to inference type information. This framework utilized Single Static Assignment (SSA) for optimizations and use graph-based register allocation algorithms for virtual register allocation.

### Example
original MSIL:
```Csharp
method public hidebysig static
 int32 Sum (
 int32 n
 ) cil managed
 {
    .maxstack 2
    .locals init (
    [0] int32 sum,
    [1] int32 i
    )
    IL_0000: ldc.i4.0
    IL_0001: stloc.0
    IL_0002: ldc.i4.1
    IL_0003: stloc.1
    IL_0004: br.s IL_000e
        // loop start (head: IL_000e)
        IL_0006: ldloc.0
        IL_0007: ldloc.1
        IL_0008: add
        IL_0009: stloc.0
        IL_000a: ldloc.1
        IL_000b: ldc.i4.1
        IL_000c: add
        IL_000d: stloc.1
        IL_000e: ldloc.1
        IL_000f: ldarg.0
        IL_0010: blt.s IL_0006
    // end loop
    IL_0012: ldloc.0
    IL_0013: ret
 } // end of method Test::Sum
 ```

 Optimized custom IL:
 ```CSharp
 Basic Block 0
 LiveInStackSize: 0
 Pred:
 Succ: #2
 [Ldc_Int] Const1[Int][1] => Reg1[Int]
 [Ldc_Int] Const0[Int][0] => Reg2[Int]
 [Br] => [2]
 Basic Block 1
 LiveInStackSize: 0
 Pred: #2
 Succ: #2
 [Add_Int] Reg1[Int] Reg2[Int] => Reg3[Int]
 [Add_Int] Const2[Int][1] Reg1[Int] => Reg4[Int]
 [Mov] Reg4[Int] => Reg1[Int]
 [Mov] Reg3[Int] => Reg2[Int]
 Basic Block 2
 LiveInStackSize: 0
 Pred: #0 #1
 Succ: #1 #3
 [Blt_Int] Reg0[Int] Reg1[Int] => [1][3]
 Basic Block 3
 LiveInStackSize: 0
 Pred: #2
 Succ:
 [Ret] Reg2[Int] =>
 ```

 ### Acknowledgement
 [InjectFix](https://github.com/Tencent/InjectFix)
 [ILRuntime](https://github.com/Ourpalm/ILRuntime)
 [HybridCLR](https://github.com/focus-creative-games/hybridclr)
